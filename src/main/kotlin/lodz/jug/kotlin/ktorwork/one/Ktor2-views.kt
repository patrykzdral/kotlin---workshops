package lodz.jug.kotlin.ktorwork.one

import io.ktor.application.Application
import io.ktor.application.call
import io.ktor.application.install
import io.ktor.features.ContentNegotiation
import io.ktor.features.StatusPages
import io.ktor.gson.gson
import io.ktor.html.*
import io.ktor.http.HttpStatusCode
import io.ktor.response.respond
import io.ktor.routing.get
import io.ktor.routing.routing
import io.ktor.server.engine.embeddedServer
import io.ktor.server.netty.Netty
import kotlinx.html.*


/**
 * Two examples of a view :
 * * html
 * ** 1) very simple html
 * ** 2) complex html with dedicated template class with content injection
 * *json
 */
fun main(args: Array<String>) {
    embeddedServer(Netty, port = 8000, module = Application::viewsModule).start(wait = true)
}


private fun Application.viewsModule() {
    routing {

        //show how html can be generated by a simple function with receiver
        get("/html1") {
            call.respondHtml(block = Views.html1)
        }

        //here we will use a temp[late with injected content
        get("/html2") {
            call.respondHtmlTemplate(Templates.MulticolumnTemplate()) {
                column1 { +"column 1 placeholder" }
                column2 { +"col2 placeholder" }
            }
        }


        //JSON with usage of ktor-gson special module - configuration in plugin/feature below
        get("/json1"){
            call.respond(listOf(
                    MyDomainObject("a",1),
                    MyDomainObject("b",2),
                    MyDomainObject("c",3)
            ))
        }
    }


    install(StatusPages) {
        status(HttpStatusCode.NotFound) {
            call.respondHtml {
                body {
                    div { +"NIMA :(" }
                }
            }
        }
    }

    //gson configuration
    install(ContentNegotiation){
        gson {
            setPrettyPrinting()
            disableHtmlEscaping()
            disableInnerClassSerialization()
            enableComplexMapKeySerialization()
        }
    }

}

data class MyDomainObject(val name:String, val value:Int)

//simple function on a receiver
private object Views {
    val html1: HTML.() -> Unit = {
        head {
            title("First Html")
        }
        body {
            h1(classes = "myClass") {
                +"Title of html1"
            }
        }

    }

}


/**
 * We have two placeholders in the main menu layout
 *
 * ** each placeholder has concrete type
 * ** 'Placeholder' is just for html
 * **  ' Template Placeholder' nests another template
 *
 * in the apply method we are injecting placeholders
 */
private object Templates {
    class MainLayout : Template<HTML> {

        val content = Placeholder<HtmlBlockTag>()

        val menu = TemplatePlaceholder<MainMenu>()

        override fun HTML.apply() {
            head {
                title { +"Template" }
            }
            body {
                 div{
                    insert(content)
                }
                insert(MainMenu(), menu)
            }
        }

    }

    /**
     * Menu template where you can insert items dynamically
     */
    class MainMenu : Template<FlowContent> {
        val item = PlaceholderList<UL, FlowContent>()
        override fun FlowContent.apply() {
            if (!item.isEmpty()) displayMenu()(this)
        }

        private fun displayMenu(): FlowContent.() -> Unit = {
            ul {
                each(item) {
                    li {
                        if (it.first) b {
                            insert(it)
                        } else {
                            insert(it)
                        }
                    }
                }
            }
        }
    }


    /**
     * This is the actual page where we leave two places for a content.
     * Content is filled when an instance is created.
     */
    class MulticolumnTemplate(val main: MainLayout = MainLayout()) : Template<HTML> {
        val column1 = Placeholder<FlowContent>()

        val column2 = Placeholder<FlowContent>()
        override fun HTML.apply() {
            insert(main) {
                menu {
                    item { +"One" }
                    item { +"Two" }
                }
                content {
                    div("column") {
                        insert(column1)
                    }
                    div("column") {
                        insert(column2)
                    }
                }
            }
        }
    }
}
